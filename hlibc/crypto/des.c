/*
 * Copyright (C) 2021-2022 John Hunter Kohler <jhunterkohler@gmail.com>
 */
#include <hlibc/string.h>
#include <hlibc/crypto/des.h>

const uint8_t IP[] = {
    0x39, 0x31, 0x29, 0x21, 0x19, 0x11, 0x09, 0x01, 0x3B, 0x33, 0x2B,
    0x23, 0x1B, 0x13, 0x0B, 0x03, 0x3D, 0x35, 0x2D, 0x25, 0x1D, 0x15,
    0x0D, 0x05, 0x3F, 0x37, 0x2F, 0x27, 0x1F, 0x17, 0x0F, 0x07, 0x38,
    0x30, 0x28, 0x20, 0x18, 0x10, 0x08, 0x00, 0x3A, 0x32, 0x2A, 0x22,
    0x1A, 0x12, 0x0A, 0x02, 0x3C, 0x34, 0x2C, 0x24, 0x1C, 0x14, 0x0C,
    0x04, 0x3E, 0x36, 0x2E, 0x26, 0x1E, 0x16, 0x0E, 0x06,
};

const uint8_t IP_inv[] = {
    0x27, 0x07, 0x2F, 0x0F, 0x37, 0x17, 0x3F, 0x1F, 0x26, 0x06, 0x2E,
    0x0E, 0x36, 0x16, 0x3E, 0x1E, 0x25, 0x05, 0x2D, 0x0D, 0x35, 0x15,
    0x3D, 0x1D, 0x24, 0x04, 0x2C, 0x0C, 0x34, 0x14, 0x3C, 0x1C, 0x23,
    0x03, 0x2B, 0x0B, 0x33, 0x13, 0x3B, 0x1B, 0x22, 0x02, 0x2A, 0x0A,
    0x32, 0x12, 0x3A, 0x1A, 0x21, 0x01, 0x29, 0x09, 0x31, 0x11, 0x39,
    0x19, 0x20, 0x00, 0x28, 0x08, 0x30, 0x10, 0x38, 0x18,
};

const uint8_t E[] = {
    0x1F, 0x00, 0x01, 0x02, 0x03, 0x04, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
    0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,
    0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
    0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x00,
};

const uint8_t P[] = {
    0x07, 0x1C, 0x15, 0x0A, 0x1A, 0x02, 0x13, 0x0D, 0x17, 0x1D, 0x05,
    0x00, 0x12, 0x08, 0x18, 0x1E, 0x16, 0x01, 0x0E, 0x1B, 0x06, 0x09,
    0x11, 0x1F, 0x0F, 0x04, 0x14, 0x03, 0x0B, 0x0C, 0x19, 0x10,
};

const uint8_t S[][64] = {
    {
        0xE, 0x0, 0x4, 0xF, 0xD, 0x7, 0x1, 0x4, 0x2, 0xE, 0xF, 0x2, 0xB,
        0xD, 0x8, 0x1, 0x3, 0xA, 0xA, 0x6, 0x6, 0xC, 0xC, 0xB, 0x5, 0x9,
        0x9, 0x5, 0x0, 0x3, 0x7, 0x8, 0x4, 0xF, 0x1, 0xC, 0xE, 0x8, 0x8,
        0x2, 0xD, 0x4, 0x6, 0x9, 0x2, 0x1, 0xB, 0x7, 0xF, 0x5, 0xC, 0xB,
        0x9, 0x3, 0x7, 0xE, 0x3, 0xA, 0xA, 0x0, 0x5, 0x6, 0x0, 0xD,
    },
    {
        0xF, 0x3, 0x1, 0xD, 0x8, 0x4, 0xE, 0x7, 0x6, 0xF, 0xB, 0x2, 0x3,
        0x8, 0x4, 0xE, 0x9, 0xC, 0x7, 0x0, 0x2, 0x1, 0xD, 0xA, 0xC, 0x6,
        0x0, 0x9, 0x5, 0xB, 0xA, 0x5, 0x0, 0xD, 0xE, 0x8, 0x7, 0xA, 0xB,
        0x1, 0xA, 0x3, 0x4, 0xF, 0xD, 0x4, 0x1, 0x2, 0x5, 0xB, 0x8, 0x6,
        0xC, 0x7, 0x6, 0xC, 0x9, 0x0, 0x3, 0x5, 0x2, 0xE, 0xF, 0x9,
    },
    {
        0xA, 0xD, 0x0, 0x7, 0x9, 0x0, 0xE, 0x9, 0x6, 0x3, 0x3, 0x4, 0xF,
        0x6, 0x5, 0xA, 0x1, 0x2, 0xD, 0x8, 0xC, 0x5, 0x7, 0xE, 0xB, 0xC,
        0x4, 0xB, 0x2, 0xF, 0x8, 0x1, 0xD, 0x1, 0x6, 0xA, 0x4, 0xD, 0x9,
        0x0, 0x8, 0x6, 0xF, 0x9, 0x3, 0x8, 0x0, 0x7, 0xB, 0x4, 0x1, 0xF,
        0x2, 0xE, 0xC, 0x3, 0x5, 0xB, 0xA, 0x5, 0xE, 0x2, 0x7, 0xC,
    },
    {
        0x7, 0xD, 0xD, 0x8, 0xE, 0xB, 0x3, 0x5, 0x0, 0x6, 0x6, 0xF, 0x9,
        0x0, 0xA, 0x3, 0x1, 0x4, 0x2, 0x7, 0x8, 0x2, 0x5, 0xC, 0xB, 0x1,
        0xC, 0xA, 0x4, 0xE, 0xF, 0x9, 0xA, 0x3, 0x6, 0xF, 0x9, 0x0, 0x0,
        0x6, 0xC, 0xA, 0xB, 0x1, 0x7, 0xD, 0xD, 0x8, 0xF, 0x9, 0x1, 0x4,
        0x3, 0x5, 0xE, 0xB, 0x5, 0xC, 0x2, 0x7, 0x8, 0x2, 0x4, 0xE,
    },
    {
        0x2, 0xE, 0xC, 0xB, 0x4, 0x2, 0x1, 0xC, 0x7, 0x4, 0xA, 0x7, 0xB,
        0xD, 0x6, 0x1, 0x8, 0x5, 0x5, 0x0, 0x3, 0xF, 0xF, 0xA, 0xD, 0x3,
        0x0, 0x9, 0xE, 0x8, 0x9, 0x6, 0x4, 0xB, 0x2, 0x8, 0x1, 0xC, 0xB,
        0x7, 0xA, 0x1, 0xD, 0xE, 0x7, 0x2, 0x8, 0xD, 0xF, 0x6, 0x9, 0xF,
        0xC, 0x0, 0x5, 0x9, 0x6, 0xA, 0x3, 0x4, 0x0, 0x5, 0xE, 0x3,
    },
    {
        0xC, 0xA, 0x1, 0xF, 0xA, 0x4, 0xF, 0x2, 0x9, 0x7, 0x2, 0xC, 0x6,
        0x9, 0x8, 0x5, 0x0, 0x6, 0xD, 0x1, 0x3, 0xD, 0x4, 0xE, 0xE, 0x0,
        0x7, 0xB, 0x5, 0x3, 0xB, 0x8, 0x9, 0x4, 0xE, 0x3, 0xF, 0x2, 0x5,
        0xC, 0x2, 0x9, 0x8, 0x5, 0xC, 0xF, 0x3, 0xA, 0x7, 0xB, 0x0, 0xE,
        0x4, 0x1, 0xA, 0x7, 0x1, 0x6, 0xD, 0x0, 0xB, 0x8, 0x6, 0xD,
    },
    {
        0x4, 0xD, 0xB, 0x0, 0x2, 0xB, 0xE, 0x7, 0xF, 0x4, 0x0, 0x9, 0x8,
        0x1, 0xD, 0xA, 0x3, 0xE, 0xC, 0x3, 0x9, 0x5, 0x7, 0xC, 0x5, 0x2,
        0xA, 0xF, 0x6, 0x8, 0x1, 0x6, 0x1, 0x6, 0x4, 0xB, 0xB, 0xD, 0xD,
        0x8, 0xC, 0x1, 0x3, 0x4, 0x7, 0xA, 0xE, 0x7, 0xA, 0x9, 0xF, 0x5,
        0x6, 0x0, 0x8, 0xF, 0x0, 0xE, 0x5, 0x2, 0x9, 0x3, 0x2, 0xC,
    },
    {
        0xD, 0x1, 0x2, 0xF, 0x8, 0xD, 0x4, 0x8, 0x6, 0xA, 0xF, 0x3, 0xB,
        0x7, 0x1, 0x4, 0xA, 0xC, 0x9, 0x5, 0x3, 0x6, 0xE, 0xB, 0x5, 0x0,
        0x0, 0xE, 0xC, 0x9, 0x7, 0x2, 0x7, 0x2, 0xB, 0x1, 0x4, 0xE, 0x1,
        0x7, 0x9, 0x4, 0xC, 0xA, 0xE, 0x8, 0x2, 0xD, 0x0, 0xF, 0x6, 0xC,
        0xA, 0x9, 0xD, 0x0, 0xF, 0x3, 0x3, 0x5, 0x5, 0x6, 0x8, 0xB,
    },
};

const uint8_t shifts[] = {
    1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1,
};

const uint8_t PC_1[] = {
    0x3C, 0x34, 0x2C, 0x24, 0x3B, 0x33, 0x2B, 0x23, 0x1B, 0x13, 0x0B, 0x03,
    0x3A, 0x32, 0x2A, 0x22, 0x1A, 0x12, 0x0A, 0x02, 0x39, 0x31, 0x29, 0x21,
    0x19, 0x11, 0x09, 0x01, 0x1C, 0x14, 0x0C, 0x04, 0x3D, 0x35, 0x2D, 0x25,
    0x1D, 0x15, 0x0D, 0x05, 0x3E, 0x36, 0x2E, 0x26, 0x1E, 0x16, 0x0E, 0x06,
    0x3F, 0x37, 0x2F, 0x27, 0x1F, 0x17, 0x0F, 0x07,
};

const uint8_t PC_2[] = {
    0x18, 0x1B, 0x14, 0x06, 0x0E, 0x0A, 0x03, 0x16, 0x00, 0x11, 0x07, 0x0C,
    0x08, 0x17, 0x0B, 0x05, 0x10, 0x1A, 0x01, 0x09, 0x13, 0x19, 0x04, 0x0F,
    0x36, 0x2B, 0x24, 0x1D, 0x31, 0x28, 0x30, 0x1E, 0x34, 0x2C, 0x25, 0x21,
    0x2E, 0x23, 0x32, 0x29, 0x1C, 0x35, 0x33, 0x37, 0x20, 0x2D, 0x27, 0x2A,
};

uint64_t des_IP(uint64_t input)
{
    uint64_t res = 0;
    for (int i = 0; i < 64; i++)
        res |= ((input >> IP[i]) & 1) << i;
    return res;
}

uint64_t des_IP_inv(uint64_t input)
{
    uint64_t res = 0;
    for (int i = 0; i < 64; i++)
        res |= ((input >> IP_inv[i]) & 1) << i;
    return res;
}

uint64_t des_E(uint32_t input)
{
    uint64_t ret = 0;
    for (int i = 0; i < 48; i++)
        ret |= ((((uint64_t)input) >> E[i]) & 1) << i;
    return ret;
}

uint32_t des_P(uint32_t input)
{
    uint32_t res = 0;
    for (int i = 0; i < 32; i++)
        res |= ((input >> P[i]) & 1) << i;
    return res;
}

uint32_t des_S(uint64_t input)
{
    uint32_t res = 0;
    for (int i = 0; i < 8; i++)
        res |= S[i][(input >> (42 - 6 * i)) & 0x3F] << (28 - 4 * i);
    return res;
}

uint32_t des_f(uint32_t block, uint64_t key)
{
    return des_P(des_S(des_E(block) ^ key));
}

uint64_t des_left_shift(uint64_t key, size_t n)
{
    uint8_t shift = shifts[n];
    uint32_t upper = key >> 28;
    uint32_t lower = key & ((1ULL << 28) - 1);

    upper = ((upper << shift) | (upper >> (28 - shift))) & ((1ULL << 28) - 1);
    lower = ((lower << shift) | (lower >> (28 - shift))) & ((1ULL << 28) - 1);

    return (((uint64_t)upper) << 28) | ((uint64_t)lower);
}

void des_schedule(uint64_t key, uint64_t *schedule)
{
    key = des_PC_1(key);
    for (int i = 0; i < 16; i++) {
        key = des_left_shift(key, i);
        schedule[i] = des_PC_2(key);
    }
}

uint64_t des_PC_1(uint64_t key)
{
    uint64_t res = 0;
    for (int i = 0; i < 56; i++)
        res |= ((key >> PC_1[i]) & 1) << i;
    return res;
}

uint64_t des_PC_2(uint64_t key)
{
    uint64_t res = 0;
    for (int i = 0; i < 48; i++)
        res |= ((key >> PC_2[i]) & 1) << i;
    return res;
}

uint64_t __des(uint64_t block, uint64_t *schedule, int flags)
{
    bool decrypt = flags & DES_DECRYPT;
    block = des_IP(block);

    for (int i = 0; i < 16; i++)
        block = block << 32 |
                ((block >> 32) ^ des_f(block, schedule[decrypt ? 15 - i : i]));

    block = des_IP_inv(block >> 32 | block << 32);
    return block;
}

uint64_t des(uint64_t block, uint64_t key, int flags)
{
    uint64_t schedule[16];
    des_schedule(key, schedule);
    return __des(block, schedule, flags);
}

/*
 * DES Encryption/Decryption in ECB mode on `src` for `size` bytes, written
 * onto `dest`.
 */
void des_ecb(void *src, size_t size, void *dest, uint64_t key, int flags)
{
    uint64_t *in = src;
    uint64_t *out = dest;
    size_t blocks = size / sizeof(*in);
    size_t rem = size % sizeof(*in);
    uint64_t schedule[16];
    des_schedule(key, schedule);

    for (int i = 0; i < blocks; i++)
        __des(in[i], schedule, flags);

    uint64_t rem_block = 0;
    memcpy(&rem_block, in + blocks, rem);

    rem_block = __des(rem_block, schedule, flags);
    memcpy(out + blocks, &rem_block, rem);
}

uint64_t __triple_des(uint64_t block, uint64_t **schedule, int *flags)
{
    uint64_t res = block;
    res = __des(res, schedule[0], flags[0]);
    res = __des(res, schedule[1], flags[1]);
    res = __des(res, schedule[2], flags[2]);
    return res;
}

uint64_t triple_des(uint64_t block, uint64_t *keys, int flags)
{
    int des_flags[3] = { 0 };
    uint64_t schedule[3][16] = { 0 };

    des_schedule(keys[0], schedule[0]);
    des_schedule(keys[1], schedule[1]);
    des_schedule(keys[2], schedule[2]);

    if (flags | TRIPLE_DES_DECRYPT) {
        des_flags[0] |= DES_DECRYPT;
        des_flags[1] |= DES_ENCRYPT;
        des_flags[2] |= DES_DECRYPT;
    } else {
        des_flags[0] |= DES_ENCRYPT;
        des_flags[1] |= DES_DECRYPT;
        des_flags[3] |= DES_ENCRYPT;
    }

    return __triple_des(block, (uint64_t **)schedule, des_flags);
}
